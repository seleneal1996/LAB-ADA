# -*- coding: utf-8 -*-
"""ADAL3.ipyn

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1e6cgZKWBr3Q0wmG2AVQUYjAP5_MQFuR2
"""

#Barrios Cornejo Selene

#PRIMER EJERCICIO
import time
import random
import matplotlib.pyplot as plt
from math import log2

def insertion_sort(A):
  #Mis variables
  comp = 0
  asig = 0
  n = len(A) # tam del Vector
  i = 1
  asig = asig + 2 # tam arreglo y el i 
  while i < n:
      comp = comp + 1 # Comparacion del while 
      var = A[i]
      j = i - 1
      asig = asig + 2 # De var y j
      while j >= 0 and A[j] > var:
          comp = comp + 2 # del while
          A[j + 1] = A[j]
          j = j - 1
          asig = asig + 2 # A[j+1] y de j 
      comp = comp + 2 # del while 
      A[j + 1] = var
      i = i + 1
      asig = asig + 2 # A[j + 1] e i 
  comp = comp + 1 # del while 
  return (comp, asig, 0, 0)

def intercala(A, p, q, r):
  comp = 0
  asig = 0
  objc = 0
  B = [0] * len(A) # tam del vector
  objc = objc + 1 
  for i in range(p, q + 1):
    comp = comp + 1# del primer for
    B[i] = A[i]
    asig = asig + 1 #linea 41
  comp = comp + 1 # de linea 39
  
  objc = objc + 1 #linea 45
  for j in range(q + 1, r + 1):
    comp = comp + 1# del segundo for
    B[q + (r - j + 1)] = A[j]
    asig = asig + 1 #linea 48
  i = p
  j = r
  asig = asig + 2#linea 50+51
  objc = objc + 1 #linea 46

  objc = objc + 1 #linea 56
  for k in range(p, r + 1):
    comp = comp + 1# del tercer for
    if B[i] <= B[j]:
      A[k] = B[i]
      i = i + 1
      asig = asig + 2 #linea 60 +61
    else:
      A[k] = B[j]
      j = j - 1
      asig = asig + 2#linea 63+64
    comp = comp + 2
    asig = asig + 2 #
  comp = comp + 2#linea 56
  return (comp,asig,objc,0)

def mergeSort(A, p, r):
  comp = 0
  asig = 0
  objc = 0
  if p < r:
    q = (p + r) // 2
    asig = asig + 1 #linea 77
    mergeSort(A, p, q)
    mergeSort(A, q + 1, r)
    intercala(A, p, q, r)
  comp = comp + 1 #linea 76
  return (comp,asig,objc,0)
  
#GENERADOR  
def Generando2(n, mode, a=0,b=100):
    comp=0
    asig=0
    c_objeto=0
    Malloc=0
    if mode == 'creciente':
        return list(range(n))
    elif mode == 'decreciente':
        return list(range(n - 1, -1, -1))
    A = [None] * n
    asig=asig+1
    c_objeto=c_objeto+1
    Malloc=Malloc+n
    for i in range(n):
        A[i] = random.randint(a, b)
        comp= comp+1
        asig=asig+2
    return A

#GRAFICOS DE COMPLEJIDAD

#Para generar nuestra escala X 
X  = list(range(1, 1000))
#Para la escala y de los algoritmos
YMerge = list(range(1, 1000)) # Merge 
YInsert_PC = list(range(1, 1000)) # Insert en peor caso
YInsert_MC = list(range(1, 1000)) # Insert en mejor caso
#Para los subplots
figure, axes = plt.subplots(nrows=2, ncols=2)
#
for i in range(len(X)):
  YMerge[i] = X[i] * log2(X[i]) #Time Complexity: O(n*log(n)).
  YInsert_PC[i] = X[i] ** 2     #Time Complexity n^2
  YInsert_MC[i] = X[i]          ##Time Complexity n
#POSICIONES DE LOS SUPLOT,COLOR Y ETIQUETA
plt.subplot(2, 2, 1)
plt.plot(X,YMerge,color='k',label='Merge')
plt.grid(True)
plt.subplot(2, 2, 2)
plt.plot(X,YInsert_PC,color='b')
plt.grid(True)

figure.tight_layout()
plt.subplot(2, 2, 3)
plt.plot(X,YInsert_MC,color='r')
plt.grid(True)
plt.subplot(2, 2, 4)
#PARA LA ESCALA
foo  = list(range(1, 10))
YMerge = list(range(1, 10)) 
YInsert_PC = list(range(1, 10)) 
YInsert_MC = list(range(1, 10)) 
for i in range(len(foo)):
  YMerge[i] = foo[i] * log2(foo[i])
  YInsert_PC[i] = foo[i] ** 2
  YInsert_MC[i] = foo[i]
#PARA REALIZAR UN VS
plt.plot(foo,
         YMerge,
         color ='k',
         label='Merge '
         )
plt.plot(foo,
         YInsert_PC,
         color ='b',
         label='Insert -Peor Caso'
         )
plt.plot(foo,
         YInsert_MC,
         color ='r',
         label='Insert -Mejor Caso'
         )

plt.grid(True)
#LEYENDA
plt.legend()

#SEGUNDO EJERCICIO
def MergeSort(A):
    Comp = 0
    asig=0
    objc=0
    if len(A)>1:
        intMidValue = len(A)//2 
        listLeftHalf = A[:intMidValue]
        listRightHalf = A[intMidValue:]
        left_part = MergeSort(listLeftHalf)
        right_part = MergeSort(listRightHalf)
        Comp += left_part[1] + right_part[1]

        i=0
        j=0
        k=0
        asig=asig+8 # de lineas 6 ->10 +13,14 y15
        while i < len(listLeftHalf) and j < len(listRightHalf):
            Comp=Comp + 2 # linea 17
            if listLeftHalf[i] < listRightHalf[j]:
                A[k]=listLeftHalf[i]
                i =i+1
                asig = asig + 2#linea 20+ 21 
            else:
                A[k]=listRightHalf[j]
                j=j+1
                asig = asig + 2
            k=k+1
            asig = asig + 2#linea 19
            Comp = Comp + 1# linea 17
        Comp = Comp + 1  #linea 17  

        while i < len(listLeftHalf):
            A[k]=listLeftHalf[i]
            i=i+1
            k=k+1
            Comp =Comp+ 1#inea 40
            asig = asig + 3#linea 33 ->35
        Comp =Comp+ 1#linea 40

        while j < len(listRightHalf):
            A[k]=listRightHalf[j]
            j=j+1
            k=k+1
            Comp=Comp+1 #linea 40
            asig = asig + 3 #linea 41-> 43
        Comp =Comp+ 1#linea 40
    Comp = Comp + 1 # del if
    return (A, Comp,asig,0)

#GRAFICOS DE COSTO MERGE-INTERCALA

Xinc=[]
Tinc=[]
for i in [5, 10, 50, 100, 500, 1000, 5000, 10000]:
  Xinc.append(i)
  t0_=time.time()
  A = Generando2(i,'creciente')
  var=len(A)-1
  (comp, asig, objc, malloc) = mergeSort(A,0,var)
  t1_=time.time()
  tiempo3=round(t1_-t0_,0)
  comparaciones= comp*2     
  Asignaciones  = asig*8     
  C_objeto   = objc * 200
  Malloc = 50 + (malloc * 10)
  TOTAL  = comparaciones + Asignaciones + C_objeto + Malloc 
  Tinc.append(TOTAL)
figure.tight_layout()

#*********************************************************************************
Xmerc=[]
Tmerc=[]
for i in [5, 10, 50, 100, 500, 1000, 5000, 10000]:
  Xmerc.append(i)
  t0_=time.time()
  A = Generando2(i,'creciente')
  (Comp, asig, objc, malloc) = MergeSort(A)
  t1_=time.time()
  tiempo3=round(t1_-t0_,0)
  comparaciones= comp*2     
  Asignaciones  = asig*8     
  C_objeto   = objc * 200
  Malloc = 50 + (malloc * 10)
  TOTAL  = comparaciones + Asignaciones + C_objeto + Malloc 
  Tmerc.append(TOTAL)
Xmerd=[]
Tmerd=[]
for i in [5, 10, 50, 100, 500, 1000, 5000, 10000]:
  Xmerd.append(i)
  t0_=time.time()
  A = Generando2(i,'decreciente')
  (Comp, asig, objc, malloc) = MergeSort(A)
  t1_=time.time()
  tiempo3=round(t1_-t0_,0)
  comparaciones= comp*2     
  Asignaciones  = asig*8     
  C_objeto   = objc * 200
  Malloc = 50 + (malloc * 10)
  TOTAL  = comparaciones + Asignaciones + C_objeto + Malloc 
  Tmerd.append(TOTAL)

plt.subplot(2, 2, 1)
plt.title('Intercala vs Merge Sort')
plt.plot(Xinc,
         Tinc,
         color ='m',
         label='Intercala'
         )
plt.plot(Xmerc,
         Tmerc,
         color ='g',
         label='MergeSort'
         )
plt.grid(True)
#LEYENDA
plt.legend()
plt.xlabel('tam')
plt.ylabel('tiempo')
plt.subplot(2, 2, 2)
plt.title('Grafica de Costo MergeSort')
plt.plot(Xmerc,
         Tmerc,
         color ='b',
         label='Mejor Caso '
         )
plt.plot(Xmerd,
         Tmerd,
         color ='r',
         label='Peor Caso'
         )
plt.grid(True)

#LEYENDA
plt.legend()
plt.xlabel('tam')
plt.ylabel('tiempo')